<!-- Code generated by gomarkdoc. DO NOT EDIT -->

[![License](https://img.shields.io/github/license/nwillc/genfuncs.svg)](https://tldrlegal.com/license/-isc-license)
[![Releases](https://img.shields.io/github/tag/nwillc/genfuncs.svg)](https://github.com/nwillc/genfuncs/tags)

# genfuncs

```go
import "github.com/nwillc/genfuncs"
```

Package genfuncs implements various functions utilizing Go's Generics to help avoid writing boilerplate code\, in particular when working with slices\. Many of the functions are based on Kotlin's Sequence\. This package\, though usable\, is primarily a proof\-of\-concept since it is likely Go will provide similar at some point soon\.

The code is under the ISC License: https://github.com/nwillc/genfuncs/blob/master/LICENSE.md

## Index

- [func Associate[T, V any, K comparable](slice []T, keyValueFor KeyValueFor[T, K, V]) map[K]V](<#func-associate>)
- [func AssociateWith[K comparable, V any](slice []K, valueFor ValueFor[K, V]) map[K]V](<#func-associatewith>)
- [func Distinct[T comparable](slice []T) []T](<#func-distinct>)
- [func FlatMap[T, R any](slice []T, function Function[T, []R]) []R](<#func-flatmap>)
- [func Fold[T, R any](slice []T, initial R, biFunction BiFunction[R, T, R]) R](<#func-fold>)
- [func GroupBy[T any, K comparable](slice []T, keyFor KeyFor[T, K]) map[K][]T](<#func-groupby>)
- [func Keys[K comparable, V any](m map[K]V) []K](<#func-keys>)
- [func Map[T, R any](slice []T, function Function[T, R]) []R](<#func-map>)
- [func Values[K comparable, V any](m map[K]V) []V](<#func-values>)
- [type BiFunction](<#type-bifunction>)
- [type Comparator](<#type-comparator>)
  - [func FunctionComparator[T, R any](transform Function[T, R], comparator Comparator[R]) Comparator[T]](<#func-functioncomparator>)
  - [func OrderedComparator[T constraints.Ordered]() Comparator[T]](<#func-orderedcomparator>)
  - [func ReverseComparator[T any](comparator Comparator[T]) Comparator[T]](<#func-reversecomparator>)
- [type ComparedOrder](<#type-comparedorder>)
- [type Function](<#type-function>)
- [type Heap](<#type-heap>)
  - [func NewHeap[T any](comparator Comparator[T]) *Heap[T]](<#func-newheap>)
  - [func (h *Heap[T]) Len() int](<#func-heap-len>)
  - [func (h *Heap[T]) Pop() T](<#func-heap-pop>)
  - [func (h *Heap[T]) Push(v T)](<#func-heap-push>)
  - [func (h *Heap[T]) PushAll(values ...T)](<#func-heap-pushall>)
- [type KeyFor](<#type-keyfor>)
- [type KeyValueFor](<#type-keyvaluefor>)
- [type Predicate](<#type-predicate>)
- [type Slice](<#type-slice>)
  - [func (s Slice[T]) All(predicate Predicate[T]) bool](<#func-slice-all>)
  - [func (s Slice[T]) Any(predicate Predicate[T]) bool](<#func-slice-any>)
  - [func (s Slice[T]) Contains(element T, comparator Comparator[T]) bool](<#func-slice-contains>)
  - [func (s Slice[T]) Filter(predicate Predicate[T]) Slice[T]](<#func-slice-filter>)
  - [func (s Slice[T]) Find(predicate Predicate[T]) (T, bool)](<#func-slice-find>)
  - [func (s Slice[T]) FindLast(predicate Predicate[T]) (T, bool)](<#func-slice-findlast>)
  - [func (s Slice[T]) JoinToString(stringer Stringer[T], separator string, prefix string, postfix string) string](<#func-slice-jointostring>)
  - [func (s Slice[T]) Sort(comparator Comparator[T])](<#func-slice-sort>)
  - [func (s Slice[T]) SortBy(comparator Comparator[T]) []T](<#func-slice-sortby>)
  - [func (s Slice[T]) Swap(i, j int)](<#func-slice-swap>)
- [type Stringer](<#type-stringer>)
  - [func StringerStringer[T fmt.Stringer]() Stringer[T]](<#func-stringerstringer>)
- [type ValueFor](<#type-valuefor>)


## func [Associate](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L20>)

```go
func Associate[T, V any, K comparable](slice []T, keyValueFor KeyValueFor[T, K, V]) map[K]V
```

Associate returns a map containing key/values created by applying a function to elements of the slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"strings"
)

func main() {
	byLastName := func(n string) (string, string) {
		parts := strings.Split(n, " ")
		return parts[1], n
	}
	names := []string{"fred flintstone", "barney rubble"}
	nameMap := genfuncs.Associate(names, byLastName)
	fmt.Println(nameMap["rubble"]) // barney rubble
}
```

</p>
</details>

## func [AssociateWith](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L31>)

```go
func AssociateWith[K comparable, V any](slice []K, valueFor ValueFor[K, V]) map[K]V
```

AssociateWith returns a Map where keys are elements from the given sequence and values are produced by the valueSelector function applied to each element\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	oddEven := func(i int) string {
		if i%2 == 0 {
			return "EVEN"
		}
		return "ODD"
	}
	numbers := []int{1, 2, 3, 4}
	odsEvensMap := genfuncs.AssociateWith(numbers, oddEven)
	fmt.Println(odsEvensMap[2]) // EVEN
	fmt.Println(odsEvensMap[3]) // ODD
}
```

</p>
</details>

## func [Distinct](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L41>)

```go
func Distinct[T comparable](slice []T) []T
```

Distinct returns a slice containing only distinct elements from the given slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	values := []int{1, 2, 2, 3, 1, 3}
	fmt.Println(genfuncs.Distinct(values)) // [1 2 3]
}
```

</p>
</details>

## func [FlatMap](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L56>)

```go
func FlatMap[T, R any](slice []T, function Function[T, []R]) []R
```

FlatMap returns a slice of all elements from results of transform function being invoked on each element of original slice\, and those resultant slices concatenated\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"strings"
)

func main() {
	words := []string{"hello", " ", "world"}
	slicer := func(s string) []string { return strings.Split(s, "") }
	fmt.Println(genfuncs.FlatMap(words, slicer)) // [h e l l o   w o r l d]
}
```

</p>
</details>

## func [Fold](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L66>)

```go
func Fold[T, R any](slice []T, initial R, biFunction BiFunction[R, T, R]) R
```

Fold accumulates a value starting with initial value and applying operation from left to right to current accumulated value and each element\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	numbers := []int{1, 2, 3, 4, 5}
	sum := func(a int, b int) int { return a + b }
	fmt.Println(genfuncs.Fold(numbers, 0, sum)) // 15
}
```

</p>
</details>

## func [GroupBy](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L76>)

```go
func GroupBy[T any, K comparable](slice []T, keyFor KeyFor[T, K]) map[K][]T
```

GroupBy groups elements of the slice by the key returned by the given keySelector function applied to each element and returns a map where each group key is associated with a slice of corresponding elements\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	oddEven := func(i int) string {
		if i%2 == 0 {
			return "EVEN"
		}
		return "ODD"
	}
	numbers := []int{1, 2, 3, 4}
	grouped := genfuncs.GroupBy(numbers, oddEven)
	fmt.Println(grouped["ODD"]) // [1 3]
}
```

</p>
</details>

## func [Keys](<https://github.com/nwillc/genfuncs/blob/master/maps.go#L20>)

```go
func Keys[K comparable, V any](m map[K]V) []K
```

Keys returns a slice of all the keys in the map\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

var wordPositions = map[string]int{"hello": 1, "world": 2}

func main() {
	keys := genfuncs.Keys(wordPositions)
	fmt.Println(keys) // [hello, world]
}
```

</p>
</details>

## func [Map](<https://github.com/nwillc/genfuncs/blob/master/slice_functions.go#L86>)

```go
func Map[T, R any](slice []T, function Function[T, R]) []R
```

Map returns a slice containing the results of applying the given transform function to each element in the original slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	numbers := []int{69, 88, 65, 77, 80, 76, 69}
	toString := func(i int) string { return string(rune(i)) }
	fmt.Println(genfuncs.Map(numbers, toString)) // [E X A M P L E]
}
```

</p>
</details>

## func [Values](<https://github.com/nwillc/genfuncs/blob/master/maps.go#L31>)

```go
func Values[K comparable, V any](m map[K]V) []V
```

Values returns a slice of all the values in the map\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

var wordPositions = map[string]int{"hello": 1, "world": 2}

func main() {
	values := genfuncs.Values(wordPositions)
	fmt.Println(values) // [1, 2]
}
```

</p>
</details>

## type [BiFunction](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L34>)

BiFunction accepts two arguments and produces a result\.

```go
type BiFunction[T, U, R any] func(T, U) R
```

## type [Comparator](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L37>)

Comparator compares two arguments of the same type and returns LessThan\, EqualTo or GreaterThan based relative order\.

```go
type Comparator[T any] BiFunction[T, T, ComparedOrder]
```

### func [FunctionComparator](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L83>)

```go
func FunctionComparator[T, R any](transform Function[T, R], comparator Comparator[R]) Comparator[T]
```

FunctionComparator composites an existing Comparator\[R\] and Function\[T\,R\] into a new Comparator\[T\]\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"time"
)

func main() {
	var unixTime = func(t time.Time) int64 { return t.Unix() }
	var timeComparator = genfuncs.FunctionComparator(unixTime, genfuncs.OrderedComparator[int64]())

	now := time.Now()
	fmt.Println(timeComparator(now, now.Add(time.Second))) // -1
}
```

</p>
</details>

### func [OrderedComparator](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L59>)

```go
func OrderedComparator[T constraints.Ordered]() Comparator[T]
```

OrderedComparator will create a Comparator from any type included in the constraints\.Ordered constraint\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

var lexicalOrder = genfuncs.OrderedComparator[string]()

func main() {
	fmt.Println(lexicalOrder("a", "b")) // -1
	fmt.Println(lexicalOrder("a", "a")) // 0
	fmt.Println(lexicalOrder("b", "a")) // 1
}
```

</p>
</details>

### func [ReverseComparator](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L73>)

```go
func ReverseComparator[T any](comparator Comparator[T]) Comparator[T]
```

ReverseComparator reverses a Comparator to facilitate switching sort orderings\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

var lexicalOrder = genfuncs.OrderedComparator[string]()
var reverseLexical = genfuncs.ReverseComparator(lexicalOrder)

func main() {
	fmt.Println(lexicalOrder("a", "b"))   // -1
	fmt.Println(reverseLexical("a", "b")) // 1
}
```

</p>
</details>

## type [ComparedOrder](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L25>)

ComparedOrder is the type returned by a Comparator\.

```go
type ComparedOrder int
```

```go
var (
    LessThan    ComparedOrder = -1
    EqualTo     ComparedOrder = 0
    GreaterThan ComparedOrder = 1
)
```

## type [Function](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L40>)

Function accepts one argument and produces a result\.

```go
type Function[T, R any] func(T) R
```

## type [Heap](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L20-L23>)

Heap implements either a min or max ordered heap of any type\.

```go
type Heap[T any] struct {
    // contains filtered or unexported fields
}
```

### func [NewHeap](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L26>)

```go
func NewHeap[T any](comparator Comparator[T]) *Heap[T]
```

NewHeap return a heap ordered based on the Comparator\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

var numericOrder = genfuncs.OrderedComparator[int]()

func main() {
	heap := genfuncs.NewHeap(numericOrder)
	heap.PushAll(3, 1, 4, 2)
	for heap.Len() > 0 {
		fmt.Print(heap.Pop()) // 1234
	}
	fmt.Println()
}
```

</p>
</details>

### func \(\*Heap\) [Len](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L31>)

```go
func (h *Heap[T]) Len() int
```

Len returns current length of the heap\.

### func \(\*Heap\) [Pop](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L49>)

```go
func (h *Heap[T]) Pop() T
```

Pop an item off the heap\.

### func \(\*Heap\) [Push](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L34>)

```go
func (h *Heap[T]) Push(v T)
```

Push a value onto the heap\.

### func \(\*Heap\) [PushAll](<https://github.com/nwillc/genfuncs/blob/master/heap.go#L40>)

```go
func (h *Heap[T]) PushAll(values ...T)
```

PushAll the values onto the Heap\.

## type [KeyFor](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L43>)

KeyFor is used for generating keys from types\, it accepts any type and returns a comparable key for it\.

```go
type KeyFor[T any, K comparable] Function[T, K]
```

## type [KeyValueFor](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L47>)

KeyValueFor is used to generate a key and value from a type\, it accepts any type\, and returns a comparable key and any value\.

```go
type KeyValueFor[T any, K comparable, V any] func(T) (K, V)
```

## type [Predicate](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L50>)

Predicate is used evaluate a value\, it accepts any type and returns a bool\.

```go
type Predicate[T any] func(T) bool
```

## type [Slice](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L23>)

```go
type Slice[T any] []T
```

### func \(Slice\) [All](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L26>)

```go
func (s Slice[T]) All(predicate Predicate[T]) bool
```

All returns true if all elements of slice match the predicate\.

### func \(Slice\) [Any](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L36>)

```go
func (s Slice[T]) Any(predicate Predicate[T]) bool
```

Any returns true if any element of the slice matches the predicate\.

### func \(Slice\) [Contains](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L46>)

```go
func (s Slice[T]) Contains(element T, comparator Comparator[T]) bool
```

Contains returns true if element is found in slice\.

### func \(Slice\) [Filter](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L56>)

```go
func (s Slice[T]) Filter(predicate Predicate[T]) Slice[T]
```

Filter returns a slice containing only elements matching the given predicate\.

### func \(Slice\) [Find](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L67>)

```go
func (s Slice[T]) Find(predicate Predicate[T]) (T, bool)
```

Find returns the first element matching the given predicate and true\, or false when no such element was found\.

### func \(Slice\) [FindLast](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L78>)

```go
func (s Slice[T]) FindLast(predicate Predicate[T]) (T, bool)
```

FindLast returns the last element matching the given predicate and true\, or false when no such element was found\.

### func \(Slice\) [JoinToString](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L92>)

```go
func (s Slice[T]) JoinToString(stringer Stringer[T], separator string, prefix string, postfix string) string
```

JoinToString creates a string from all the elements using the stringer on each\, separating them using separator\, and using the given prefix and postfix\.

### func \(Slice\) [Sort](<https://github.com/nwillc/genfuncs/blob/master/sort.go#L20>)

```go
func (s Slice[T]) Sort(comparator Comparator[T])
```

Sort sorts a slice by Comparator order\.

### func \(Slice\) [SortBy](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L108>)

```go
func (s Slice[T]) SortBy(comparator Comparator[T]) []T
```

SortBy copies a slice\, sorts the copy applying the Comparator and returns it\.

### func \(Slice\) [Swap](<https://github.com/nwillc/genfuncs/blob/master/slice_fluent.go#L116>)

```go
func (s Slice[T]) Swap(i, j int)
```

Swap two values in the slice\.

## type [Stringer](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L53>)

Stringer is used to create string representations\, it accepts any type and returns a string\.

```go
type Stringer[T any] func(T) string
```

### func [StringerStringer](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L78>)

```go
func StringerStringer[T fmt.Stringer]() Stringer[T]
```

StringerStringer creates a Stringer for any type that implements fmt\.Stringer\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"time"
)

func main() {
	var epoch time.Time
	fmt.Println(epoch.String()) // 0001-01-01 00:00:00 +0000 UTC
	stringer := genfuncs.StringerStringer[time.Time]()
	fmt.Println(stringer(epoch)) // 0001-01-01 00:00:00 +0000 UTC
}
```

</p>
</details>

## type [ValueFor](<https://github.com/nwillc/genfuncs/blob/master/function_types.go#L56>)

ValueFor given a comparable key will return a value for it\.

```go
type ValueFor[K comparable, T any] Function[K, T]
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
