<!-- Code generated by gomarkdoc. DO NOT EDIT -->

[![License](https://img.shields.io/github/license/nwillc/genfuncs.svg)](https://tldrlegal.com/license/-isc-license)
[![CI](https://github.com/nwillc/genfuncs/workflows/CI/badge.svg)](https://github.com/nwillc/genfuncs/actions/workflows/CI.yml)
[![codecov.io](https://codecov.io/github/nwillc/genfuncs/coverage.svg?branch=master)](https://codecov.io/github/nwillc/genfuncs?branch=master)
[![Releases](https://img.shields.io/github/tag/nwillc/genfuncs.svg)](https://github.com/nwillc/genfuncs/tags)

# Go Get
 
 ```bash
 go get github.com/nwillc/genfuncs
 ```

# Packages
- [genfuncs](<#genfuncs>)
- [genfuncs/container](<#container>)

# genfuncs

```go
import "github.com/nwillc/genfuncs"
```

Package genfuncs implements various functions utilizing Go's Generics to help avoid writing boilerplate code\, in particular when working with slices\. Many of the functions are based on Kotlin's Sequence\. This package\, though usable\, is primarily a proof\-of\-concept since it is likely Go will provide similar at some point soon\.

Examples are found in examples\_test\.go files or projects like https://github.com/nwillc/gordle

The code is under the ISC License: https://github.com/nwillc/genfuncs/blob/master/LICENSE.md

## Index

- [Variables](<#variables>)
- [func EqualComparable[C comparable](a, b C) bool](<#func-equalcomparable>)
- [func GreaterThanOrdered[O constraints.Ordered](a, b O) bool](<#func-greaterthanordered>)
- [func LessThanOrdered[O constraints.Ordered](a, b O) bool](<#func-lessthanordered>)
- [func Max[T constraints.Ordered](v ...T) T](<#func-max>)
- [func Min[T constraints.Ordered](v ...T) T](<#func-min>)
- [type BiFunction](<#type-bifunction>)
  - [func Reverse[T any](lessThan BiFunction[T, T, bool]) BiFunction[T, T, bool]](<#func-reverse>)
  - [func TransformArgs[T1, T2, R any](function Function[T1, T2], biFunction BiFunction[T2, T2, R]) BiFunction[T1, T1, R]](<#func-transformargs>)
- [type Function](<#type-function>)
  - [func Curried[A, B, R any](biFunction BiFunction[A, B, R], a A) Function[B, R]](<#func-curried>)
  - [func IsEqualComparable[C comparable](a C) Function[C, bool]](<#func-isequalcomparable>)
  - [func IsGreaterThanOrdered[O constraints.Ordered](a O) Function[O, bool]](<#func-isgreaterthanordered>)
  - [func IsLessThanOrdered[O constraints.Ordered](a O) Function[O, bool]](<#func-islessthanordered>)
  - [func Not[T any](function Function[T, bool]) Function[T, bool]](<#func-not>)
- [type MapKeyFor](<#type-mapkeyfor>)
- [type MapKeyValueFor](<#type-mapkeyvaluefor>)
- [type MapValueFor](<#type-mapvaluefor>)
- [type ToString](<#type-tostring>)
  - [func StringerToString[T fmt.Stringer]\(\) ToString[T]](<#func-stringertostring>)


## Variables

```go
var (
    F32NumericOrder        = LessThanOrdered[float32]
    F32ReverseNumericOrder = Reverse(F32NumericOrder)
    INumericOrder          = LessThanOrdered[int]
    IReverseNumericOrder   = Reverse(INumericOrder)
    I64NumericOrder        = LessThanOrdered[int64]
    I64ReverseNumericOrder = Reverse(I64NumericOrder)
    SLexicalOrder          = LessThanOrdered[string]
    SReverseLexicalOrder   = Reverse(SLexicalOrder)

    IsBlank    = IsEqualComparable("")
    IsNotBlank = Not(IsBlank)

    F32IsZero = IsEqualComparable(float32(0.0))
    F64IsZero = IsEqualComparable(0.0)
    IIsZero   = IsEqualComparable(0)
)
```

```go
var IllegalArguments = fmt.Errorf("illegal arguments")
```

NoSuchElement error is used by panics when attempts are made to access out of bounds\.

```go
var NoSuchElement = fmt.Errorf("no such element")
```

## func [EqualComparable](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L47>)

```go
func EqualComparable[C comparable](a, b C) bool
```

EqualComparable tests equality of two given comparable values\.

## func [GreaterThanOrdered](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L57>)

```go
func GreaterThanOrdered[O constraints.Ordered](a, b O) bool
```

GreaterThanOrdered tests if constraints\.Ordered a is greater than b\.

## func [LessThanOrdered](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L67>)

```go
func LessThanOrdered[O constraints.Ordered](a, b O) bool
```

LessThanOrdered tests if constraints\.Ordered a is less than b\.

## func [Max](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L77>)

```go
func Max[T constraints.Ordered](v ...T) T
```

Max returns max value of two constraints\.Ordered values\,

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	fmt.Println(genfuncs.Max(1, 2))         // 2
	fmt.Println(genfuncs.Max("dog", "cat")) // dog
}
```

</p>
</details>

## func [Min](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L91>)

```go
func Min[T constraints.Ordered](v ...T) T
```

Min returns min value of two constraints\.Ordered values\,

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
)

func main() {
	fmt.Println(genfuncs.Min(1, 2))         // 1
	fmt.Println(genfuncs.Min("dog", "cat")) // cat
}
```

</p>
</details>

## type [BiFunction](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L20>)

BiFunction accepts two arguments and produces a result\.

```go
type BiFunction[T, U, R any] func(T, U) R
```

### func [Reverse](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L105>)

```go
func Reverse[T any](lessThan BiFunction[T, T, bool]) BiFunction[T, T, bool]
```

Reverse reverses a LessThan to facilitate reverse sort ordering\.

### func [TransformArgs](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L115>)

```go
func TransformArgs[T1, T2, R any](function Function[T1, T2], biFunction BiFunction[T2, T2, R]) BiFunction[T1, T1, R]
```

TransformArgs uses the function to the arguments to be passed to the BiFunction\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"time"
)

func main() {
	var unixTime = func(t time.Time) int64 { return t.Unix() }
	var chronoOrder = genfuncs.TransformArgs(unixTime, genfuncs.I64NumericOrder)
	now := time.Now()
	fmt.Println(chronoOrder(now, now.Add(time.Second))) // true
}
```

</p>
</details>

## type [Function](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L23>)

Function is a single argument function\.

```go
type Function[T, R any] func(T) R
```

### func [Curried](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L122>)

```go
func Curried[A, B, R any](biFunction BiFunction[A, B, R], a A) Function[B, R]
```

Curried takes a BiFunction and one argument\, and Curries the function to return a single argument Function\.

### func [IsEqualComparable](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L52>)

```go
func IsEqualComparable[C comparable](a C) Function[C, bool]
```

IsEqualComparable creates a Predicate that tests equality with a given comparable value\.

### func [IsGreaterThanOrdered](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L62>)

```go
func IsGreaterThanOrdered[O constraints.Ordered](a O) Function[O, bool]
```

IsGreaterThanOrdered return a GreaterThanOrdered for a\.

### func [IsLessThanOrdered](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L72>)

```go
func IsLessThanOrdered[O constraints.Ordered](a O) Function[O, bool]
```

IsLessThanOrdered returns a LessThanOrdered for a\.

### func [Not](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L127>)

```go
func Not[T any](function Function[T, bool]) Function[T, bool]
```

Not takes a Function returning a bool and returns a Function that inverts the result\.

## type [MapKeyFor](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L26>)

MapKeyFor is used for generating keys from types\, it accepts any type and returns a comparable key for it\.

```go
type MapKeyFor[T any, K comparable] func(T) K
```

## type [MapKeyValueFor](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L30>)

MapKeyValueFor is used to generate a key and value from a type\, it accepts any type\, and returns a comparable key and any value\.

```go
type MapKeyValueFor[T any, K comparable, V any] func(T) (K, V)
```

## type [MapValueFor](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L33>)

MapValueFor given a comparable key will return a value for it\.

```go
type MapValueFor[K comparable, T any] func(K) T
```

## type [ToString](<https://github.com/nwillc/genfuncs/blob/master/functions.go#L36>)

ToString is used to create string representations\, it accepts any type and returns a string\.

```go
type ToString[T any] func(T) string
```

### func [StringerToString](<https://github.com/nwillc/genfuncs/blob/master/dry.go#L110>)

```go
func StringerToString[T fmt.Stringer]() ToString[T]
```

StringerToString creates a ToString for any type that implements fmt\.Stringer\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"time"
)

func main() {
	var epoch time.Time
	fmt.Println(epoch.String()) // 0001-01-01 00:00:00 +0000 UTC
	stringer := genfuncs.StringerToString[time.Time]()
	fmt.Println(stringer(epoch)) // 0001-01-01 00:00:00 +0000 UTC
}
```

</p>
</details>

# container

```go
import "github.com/nwillc/genfuncs/container"
```

## Index

- [func Associate[T, V any, K comparable](slice Slice[T], keyValueFor genfuncs.MapKeyValueFor[T, K, V]) map[K]V](<#func-associate>)
- [func AssociateWith[K comparable, V any](slice Slice[K], valueFor genfuncs.MapValueFor[K, V]) map[K]V](<#func-associatewith>)
- [func Contains[K comparable, V any](m map[K]V, key K) bool](<#func-contains>)
- [func Fold[T, R any](slice Slice[T], initial R, biFunction genfuncs.BiFunction[R, T, R]) R](<#func-fold>)
- [func GroupBy[T any, K comparable](slice Slice[T], keyFor genfuncs.MapKeyFor[T, K]) map[K]Slice[T]](<#func-groupby>)
- [type Bag](<#type-bag>)
- [type Deque](<#type-deque>)
  - [func NewDeque[T any](t ...T) *Deque[T]](<#func-newdeque>)
  - [func (d *Deque[T]) Add(t T)](<#func-deque-add>)
  - [func (d *Deque[T]) AddAll(t ...T)](<#func-deque-addall>)
  - [func (d *Deque[T]) AddLeft(t T)](<#func-deque-addleft>)
  - [func (d *Deque[T]) AddRight(t T)](<#func-deque-addright>)
  - [func (d *Deque[T]) Cap() int](<#func-deque-cap>)
  - [func (d *Deque[T]) Len() int](<#func-deque-len>)
  - [func (d *Deque[T]) Peek() T](<#func-deque-peek>)
  - [func (d *Deque[T]) PeekLeft() T](<#func-deque-peekleft>)
  - [func (d *Deque[T]) PeekRight() T](<#func-deque-peekright>)
  - [func (d *Deque[T]) Remove() T](<#func-deque-remove>)
  - [func (d *Deque[T]) RemoveLeft() T](<#func-deque-removeleft>)
  - [func (d *Deque[T]) RemoveRight() T](<#func-deque-removeright>)
  - [func (d *Deque[T]) Values() Slice[T]](<#func-deque-values>)
- [type Heap](<#type-heap>)
  - [func NewHeap[T any](lessThan genfuncs.BiFunction[T, T, bool], values ...T) *Heap[T]](<#func-newheap>)
  - [func (h *Heap[T]) Add(v T)](<#func-heap-add>)
  - [func (h *Heap[T]) AddAll(values ...T)](<#func-heap-addall>)
  - [func (h *Heap[T]) Len() int](<#func-heap-len>)
  - [func (h *Heap[T]) Peek() T](<#func-heap-peek>)
  - [func (h *Heap[T]) Remove() T](<#func-heap-remove>)
  - [func (h *Heap[T]) Values() Slice[T]](<#func-heap-values>)
- [type MapSet](<#type-mapset>)
  - [func NewMapSet[T comparable](t ...T) *MapSet[T]](<#func-newmapset>)
  - [func ToSet[T comparable](slice Slice[T]) *MapSet[T]](<#func-toset>)
  - [func (h *MapSet[T]) Add(t T)](<#func-mapset-add>)
  - [func (h *MapSet[T]) AddAll(t ...T)](<#func-mapset-addall>)
  - [func (h *MapSet[T]) Contains(t T) bool](<#func-mapset-contains>)
  - [func (h *MapSet[T]) Len() int](<#func-mapset-len>)
  - [func (h *MapSet[T]) Remove(t T)](<#func-mapset-remove>)
  - [func (h *MapSet[T]) Values() Slice[T]](<#func-mapset-values>)
- [type Queue](<#type-queue>)
- [type Set](<#type-set>)
- [type Slice](<#type-slice>)
  - [func Distinct[T comparable](slice Slice[T]) Slice[T]](<#func-distinct>)
  - [func FlatMap[T, R any](slice Slice[T], function genfuncs.Function[T, Slice[R]]) Slice[R]](<#func-flatmap>)
  - [func Keys[K comparable, V any](m map[K]V) Slice[K]](<#func-keys>)
  - [func Map[T, R any](slice Slice[T], function genfuncs.Function[T, R]) Slice[R]](<#func-map>)
  - [func Values[K comparable, V any](m map[K]V) Slice[V]](<#func-values>)
  - [func (s Slice[T]) All(predicate genfuncs.Function[T, bool]) bool](<#func-slice-all>)
  - [func (s Slice[T]) Any(predicate genfuncs.Function[T, bool]) bool](<#func-slice-any>)
  - [func (s Slice[T]) Compare(s2 Slice[T], comparison genfuncs.BiFunction[T, T, bool]) bool](<#func-slice-compare>)
  - [func (s Slice[T]) Filter(predicate genfuncs.Function[T, bool]) Slice[T]](<#func-slice-filter>)
  - [func (s Slice[T]) Find(predicate genfuncs.Function[T, bool]) (T, bool)](<#func-slice-find>)
  - [func (s Slice[T]) FindLast(predicate genfuncs.Function[T, bool]) (T, bool)](<#func-slice-findlast>)
  - [func (s Slice[T]) ForEach(fn func(t T))](<#func-slice-foreach>)
  - [func (s Slice[T]) ForEachI(fn func(i int, t T))](<#func-slice-foreachi>)
  - [func (s Slice[T]) JoinToString(stringer genfuncs.ToString[T], separator string, prefix string, postfix string) string](<#func-slice-jointostring>)
  - [func (s Slice[T]) Random() T](<#func-slice-random>)
  - [func (s Slice[T]) Sort(lessThan genfuncs.BiFunction[T, T, bool])](<#func-slice-sort>)
  - [func (s Slice[T]) SortBy(lessThan genfuncs.BiFunction[T, T, bool]) Slice[T]](<#func-slice-sortby>)
  - [func (s Slice[T]) Swap(i, j int)](<#func-slice-swap>)


## func [Associate](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L24>)

```go
func Associate[T, V any, K comparable](slice Slice[T], keyValueFor genfuncs.MapKeyValueFor[T, K, V]) map[K]V
```

Associate returns a map containing key/values created by applying a function to elements of the slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
	"strings"
)

func main() {
	byLastName := func(n string) (string, string) {
		parts := strings.Split(n, " ")
		return parts[1], n
	}
	names := []string{"fred flintstone", "barney rubble"}
	nameMap := container.Associate(names, byLastName)
	fmt.Println(nameMap["rubble"]) // barney rubble
}
```

</p>
</details>

## func [AssociateWith](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L35>)

```go
func AssociateWith[K comparable, V any](slice Slice[K], valueFor genfuncs.MapValueFor[K, V]) map[K]V
```

AssociateWith returns a Map where keys are elements from the given sequence and values are produced by the valueSelector function applied to each element\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	oddEven := func(i int) string {
		if i%2 == 0 {
			return "EVEN"
		}
		return "ODD"
	}
	numbers := []int{1, 2, 3, 4}
	odsEvensMap := container.AssociateWith(numbers, oddEven)
	fmt.Println(odsEvensMap[2]) // EVEN
	fmt.Println(odsEvensMap[3]) // ODD
}
```

</p>
</details>

## func [Contains](<https://github.com/nwillc/genfuncs/blob/master/container/map_functions.go#L20>)

```go
func Contains[K comparable, V any](m map[K]V, key K) bool
```

Contains tests if a map contains an entry for a given key\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

var wordPositions = map[string]int{"hello": 1, "world": 2}

func main() {
	fmt.Println(container.Contains(wordPositions, "hello")) // true
	fmt.Println(container.Contains(wordPositions, "no"))    // false
}
```

</p>
</details>

## func [Fold](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L61>)

```go
func Fold[T, R any](slice Slice[T], initial R, biFunction genfuncs.BiFunction[R, T, R]) R
```

Fold accumulates a value starting with initial value and applying operation from left to right to current accumulated value and each element\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	numbers := []int{1, 2, 3, 4, 5}
	sum := func(a int, b int) int { return a + b }
	fmt.Println(container.Fold(numbers, 0, sum)) // 15
}
```

</p>
</details>

## func [GroupBy](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L71>)

```go
func GroupBy[T any, K comparable](slice Slice[T], keyFor genfuncs.MapKeyFor[T, K]) map[K]Slice[T]
```

GroupBy groups elements of the slice by the key returned by the given keySelector function applied to each element and returns a map where each group key is associated with a slice of corresponding elements\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	oddEven := func(i int) string {
		if i%2 == 0 {
			return "EVEN"
		}
		return "ODD"
	}
	numbers := []int{1, 2, 3, 4}
	grouped := container.GroupBy(numbers, oddEven)
	fmt.Println(grouped["ODD"]) // [1 3]
}
```

</p>
</details>

## type [Bag](<https://github.com/nwillc/genfuncs/blob/master/container/bag.go#L20-L29>)

Bag is a minimal container that accepts elements\.

```go
type Bag[T any] interface {
    // Add an element to the Bag.
    Add(t T)
    // AddAll elements to the Bag.
    AddAll(t ...T)
    // Len returns length of the Bag.
    Len() int
    // Values returns a copy of the current values in the Bag without modifying the contents.
    Values() Slice[T]
}
```

## type [Deque](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L25-L31>)

Deque is a doubly ended Queue with default behavior of a Fifo but provides left and right access\.

```go
type Deque[T any] struct {
    // contains filtered or unexported fields
}
```

### func [NewDeque](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L34>)

```go
func NewDeque[T any](t ...T) *Deque[T]
```

NewDeque creates a Deque containing any provided elements\.

### func \(\*Deque\) [Add](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L41>)

```go
func (d *Deque[T]) Add(t T)
```

Add an element to the right of the Deque\.

### func \(\*Deque\) [AddAll](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L46>)

```go
func (d *Deque[T]) AddAll(t ...T)
```

AddAll elements to the right of the Deque\.

### func \(\*Deque\) [AddLeft](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L53>)

```go
func (d *Deque[T]) AddLeft(t T)
```

AddLeft an element to the left of the Deque\.

### func \(\*Deque\) [AddRight](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L61>)

```go
func (d *Deque[T]) AddRight(t T)
```

AddRight an element to the right of the Deque\.

### func \(\*Deque\) [Cap](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L124>)

```go
func (d *Deque[T]) Cap() int
```

Cap returns the capacity of the Deque\.

### func \(\*Deque\) [Len](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L69>)

```go
func (d *Deque[T]) Len() int
```

Len reports the length of the Deque\.

### func \(\*Deque\) [Peek](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L74>)

```go
func (d *Deque[T]) Peek() T
```

Peek returns the left most element in the Deque without removing it\.

### func \(\*Deque\) [PeekLeft](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L79>)

```go
func (d *Deque[T]) PeekLeft() T
```

PeekLeft returns the left most element in the Deque without removing it\.

### func \(\*Deque\) [PeekRight](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L85>)

```go
func (d *Deque[T]) PeekRight() T
```

PeekRight returns the right most element in the Deque without removing it\.

### func \(\*Deque\) [Remove](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L92>)

```go
func (d *Deque[T]) Remove() T
```

Remove and return the left most element in the Deque\.

### func \(\*Deque\) [RemoveLeft](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L97>)

```go
func (d *Deque[T]) RemoveLeft() T
```

RemoveLeft and return the left most element in the Deque\.

### func \(\*Deque\) [RemoveRight](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L107>)

```go
func (d *Deque[T]) RemoveRight() T
```

RemoveRight and return the right most element in the Deque\.

### func \(\*Deque\) [Values](<https://github.com/nwillc/genfuncs/blob/master/container/deque.go#L117>)

```go
func (d *Deque[T]) Values() Slice[T]
```

Values in the Deque returned in a new Slice\.

## type [Heap](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L27-L31>)

Heap implements either a min or max ordered heap of any type\. Heap implements Queue\.

```go
type Heap[T any] struct {
    // contains filtered or unexported fields
}
```

### func [NewHeap](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L34>)

```go
func NewHeap[T any](lessThan genfuncs.BiFunction[T, T, bool], values ...T) *Heap[T]
```

NewHeap return a heap ordered based on the LessThan and pushes any values provided\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	heap := container.NewHeap(genfuncs.INumericOrder, 3, 1, 4, 2)
	for heap.Len() > 0 {
		fmt.Print(heap.Remove())
	}
	fmt.Println()
	// 1234
}
```

</p>
</details>

### func \(\*Heap\) [Add](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L44>)

```go
func (h *Heap[T]) Add(v T)
```

Add a value onto the heap\.

### func \(\*Heap\) [AddAll](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L51>)

```go
func (h *Heap[T]) AddAll(values ...T)
```

AddAll the values onto the Heap\.

### func \(\*Heap\) [Len](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L41>)

```go
func (h *Heap[T]) Len() int
```

Len returns current length of the heap\.

### func \(\*Heap\) [Peek](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L60>)

```go
func (h *Heap[T]) Peek() T
```

Peek returns the next element without removing it\.

### func \(\*Heap\) [Remove](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L75>)

```go
func (h *Heap[T]) Remove() T
```

Remove an item off the heap\.

### func \(\*Heap\) [Values](<https://github.com/nwillc/genfuncs/blob/master/container/heap.go#L83>)

```go
func (h *Heap[T]) Values() Slice[T]
```

Values returns a slice of the values in the Heap in no particular order\.

## type [MapSet](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L26-L28>)

MapSet is a Set implementation based on a map\. MapSet implements Set\.

```go
type MapSet[T comparable] struct {
    // contains filtered or unexported fields
}
```

### func [NewMapSet](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L31>)

```go
func NewMapSet[T comparable](t ...T) *MapSet[T]
```

NewMapSet returns a new MapSet containing given values\.

### func [ToSet](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L89>)

```go
func ToSet[T comparable](slice Slice[T]) *MapSet[T]
```

### func \(\*MapSet\) [Add](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L38>)

```go
func (h *MapSet[T]) Add(t T)
```

Add element to MapSet\.

### func \(\*MapSet\) [AddAll](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L43>)

```go
func (h *MapSet[T]) AddAll(t ...T)
```

AddAll elements to MapSet\.

### func \(\*MapSet\) [Contains](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L50>)

```go
func (h *MapSet[T]) Contains(t T) bool
```

Contains returns true if MapSet contains element\.

### func \(\*MapSet\) [Len](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L56>)

```go
func (h *MapSet[T]) Len() int
```

Len returns the length of the MapSet\.

### func \(\*MapSet\) [Remove](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L61>)

```go
func (h *MapSet[T]) Remove(t T)
```

Remove an element from the MapSet\.

### func \(\*MapSet\) [Values](<https://github.com/nwillc/genfuncs/blob/master/container/map_set.go#L66>)

```go
func (h *MapSet[T]) Values() Slice[T]
```

Values returns the elements in the MapSet as a Slice\.

## type [Queue](<https://github.com/nwillc/genfuncs/blob/master/container/queue.go#L20-L26>)

Queue is a container providing some define order when accessing elements\.

```go
type Queue[T any] interface {

    // Peek returns the next element without removing it.
    Peek() T
    // Remove a given element from the Queue.
    Remove() T
    // contains filtered or unexported methods
}
```

## type [Set](<https://github.com/nwillc/genfuncs/blob/master/container/set.go#L20-L28>)

Set is a container that contains no duplicate elements\.

```go
type Set[T comparable] interface {

    // Contains returns true if the Set contains a given element.
    Contains(t T) bool
    // Values in the Set as a Slice.
    Values() Slice[T]
    // Remove a given element from the Set.
    Remove(t T)
    // contains filtered or unexported methods
}
```

## type [Slice](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L31>)

Slice is a generic type corresponding to a standard Go slice\.

```go
type Slice[T any] []T
```

### func [Distinct](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L45>)

```go
func Distinct[T comparable](slice Slice[T]) Slice[T]
```

Distinct returns a slice containing only distinct elements from the given slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	values := []int{1, 2, 2, 3, 1, 3}
	fmt.Println(container.Distinct(values)) // [1 2 3]
}
```

</p>
</details>

### func [FlatMap](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L51>)

```go
func FlatMap[T, R any](slice Slice[T], function genfuncs.Function[T, Slice[R]]) Slice[R]
```

FlatMap returns a slice of all elements from results of transform function being invoked on each element of original slice\, and those resultant slices concatenated\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs"
	"github.com/nwillc/genfuncs/container"
	"strings"
)

var words container.Slice[string] = []string{"hello", "world"}

func main() {
	slicer := func(s string) container.Slice[string] { return strings.Split(s, "") }
	fmt.Println(container.FlatMap(words.SortBy(genfuncs.SLexicalOrder), slicer)) // [h e l l o w o r l d]
}
```

</p>
</details>

### func [Keys](<https://github.com/nwillc/genfuncs/blob/master/container/map_functions.go#L26>)

```go
func Keys[K comparable, V any](m map[K]V) Slice[K]
```

Keys returns a slice of all the keys in the map\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

var wordPositions = map[string]int{"hello": 1, "world": 2}

func main() {
	keys := container.Keys(wordPositions)
	fmt.Println(keys) // [hello, world]
}
```

</p>
</details>

### func [Map](<https://github.com/nwillc/genfuncs/blob/master/container/slice_functions.go#L81>)

```go
func Map[T, R any](slice Slice[T], function genfuncs.Function[T, R]) Slice[R]
```

Map returns a slice containing the results of applying the given transform function to each element in the original slice\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

func main() {
	numbers := []int{69, 88, 65, 77, 80, 76, 69}
	toString := func(i int) string { return string(rune(i)) }
	fmt.Println(container.Map(numbers, toString)) // [E X A M P L E]
}
```

</p>
</details>

### func [Values](<https://github.com/nwillc/genfuncs/blob/master/container/map_functions.go#L37>)

```go
func Values[K comparable, V any](m map[K]V) Slice[V]
```

Values returns a slice of all the values in the map\.

<details><summary>Example</summary>
<p>

```go
package main

import (
	"fmt"
	"github.com/nwillc/genfuncs/container"
)

var wordPositions = map[string]int{"hello": 1, "world": 2}

func main() {
	values := container.Values(wordPositions)
	fmt.Println(values) // [1, 2]
}
```

</p>
</details>

### func \(Slice\) [All](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L34>)

```go
func (s Slice[T]) All(predicate genfuncs.Function[T, bool]) bool
```

All returns true if all elements of slice match the predicate\.

### func \(Slice\) [Any](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L44>)

```go
func (s Slice[T]) Any(predicate genfuncs.Function[T, bool]) bool
```

Any returns true if any element of the slice matches the predicate\.

### func \(Slice\) [Compare](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L55>)

```go
func (s Slice[T]) Compare(s2 Slice[T], comparison genfuncs.BiFunction[T, T, bool]) bool
```

Compare one Slice to another\, applying a comparison to each pair of corresponding entries\. Compare returns true if all the pair's comparison return true\. While the comparison might test equality it could have any behavior\.

### func \(Slice\) [Filter](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L68>)

```go
func (s Slice[T]) Filter(predicate genfuncs.Function[T, bool]) Slice[T]
```

Filter returns a slice containing only elements matching the given predicate\.

### func \(Slice\) [Find](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L79>)

```go
func (s Slice[T]) Find(predicate genfuncs.Function[T, bool]) (T, bool)
```

Find returns the first element matching the given predicate and true\, or false when no such element was found\.

### func \(Slice\) [FindLast](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L90>)

```go
func (s Slice[T]) FindLast(predicate genfuncs.Function[T, bool]) (T, bool)
```

FindLast returns the last element matching the given predicate and true\, or false when no such element was found\.

### func \(Slice\) [ForEach](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L104>)

```go
func (s Slice[T]) ForEach(fn func(t T))
```

ForEach element of the Slice invoke given function with the element\. Syntactic sugar for a range that intends to traverse all the elements\, i\.e\. no exiting midway through\.

### func \(Slice\) [ForEachI](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L112>)

```go
func (s Slice[T]) ForEachI(fn func(i int, t T))
```

ForEachI element of the Slice invoke given function with the element and its index in the Slice\. Syntactic sugar for a range that intends to traverse all the elements\, i\.e\. no exiting midway through\.

### func \(Slice\) [JoinToString](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L120>)

```go
func (s Slice[T]) JoinToString(stringer genfuncs.ToString[T], separator string, prefix string, postfix string) string
```

JoinToString creates a string from all the elements using the stringer on each\, separating them using separator\, and using the given prefix and postfix\.

### func \(Slice\) [Random](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L134>)

```go
func (s Slice[T]) Random() T
```

### func \(Slice\) [Sort](<https://github.com/nwillc/genfuncs/blob/master/container/sort.go#L24>)

```go
func (s Slice[T]) Sort(lessThan genfuncs.BiFunction[T, T, bool])
```

Sort sorts a slice by the LessThan order\.

### func \(Slice\) [SortBy](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L139>)

```go
func (s Slice[T]) SortBy(lessThan genfuncs.BiFunction[T, T, bool]) Slice[T]
```

SortBy copies a slice\, sorts the copy applying the Comparator and returns it\.

### func \(Slice\) [Swap](<https://github.com/nwillc/genfuncs/blob/master/container/slice.go#L147>)

```go
func (s Slice[T]) Swap(i, j int)
```

Swap two values in the slice\.

# version

```go
import "github.com/nwillc/genfuncs/gen/version"
```

## Index

- [Constants](<#constants>)


## Constants

Version number for official releases\.

```go
const Version = "v0.6.5"
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
